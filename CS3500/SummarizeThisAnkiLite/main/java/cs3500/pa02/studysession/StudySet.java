package cs3500.pa02.studysession;

import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.List;
import java.util.ListIterator;
import java.util.Map;
import java.util.Objects;
import java.util.Optional;
import java.util.Random;
import java.util.stream.Collectors;

/**
 * Represents a study set.
 */
public class StudySet {

  /**
   * All the cards in the set.
   */
  private final List<Card> cards = new ArrayList<>();
  /**
   * The cards used in a particular session. Generated using the user's input and shuffled using a
   * random.
   */
  private final List<Card> sessionCards = new ArrayList<>();
  /**
   * The Random used to shuffle the cards.
   */
  private final Random random;
  /**
   * The Card iterator to iterate through the session cards.
   */
  private ListIterator<Card> cardIterator;

  /**
   * Instantiates a new Study set using the current time as the seed for the random.
   */
  public StudySet() {
    this(System.currentTimeMillis());
  }

  /**
   * Instantiates a new Study set using a given seed for the random.
   *
   * @param seed the seed for the random
   */
  public StudySet(long seed) {
    this.random = new Random(seed);
  }

  /**
   * Shuffles cards by difficulty and updates the session cards to contain all cards in a shuffled
   * order but with hard questions before any of the easy ones. Generates the session stats based on
   * the separated lists.
   *
   * @return the session stats based on the grouped list of questions
   */
  private SessionStats shuffleCardsByDifficulty() {
    SessionStats stats = null;
    Map<CardDifficulty, List<Card>> cardsByType = this.cards.stream()
        .collect(Collectors.groupingBy(Card::getDifficulty));
    if (!cardsByType.isEmpty()) {
      List<Card> tempHard = Optional.ofNullable(cardsByType.get(CardDifficulty.HARD))
          .orElseGet(ArrayList::new);
      List<Card> tempEasy = Optional.ofNullable(cardsByType.get(CardDifficulty.EASY))
          .orElseGet(ArrayList::new);
      Collections.shuffle(tempEasy, this.random);
      Collections.shuffle(tempHard, this.random);
      this.cards.clear();
      this.cards.addAll(tempHard);
      this.cards.addAll(tempEasy);
      stats = new SessionStats(tempHard.size(), tempEasy.size());
    }
    return stats;
  }

  /**
   * Sets up the study set with the appropriate amount of shuffled questions and the initial values
   * for the statistics.
   *
   * @param numberOfQuestions the number of questions
   * @return the session stats based on the generated session card list
   */
  public SessionStats setUpStudySet(int numberOfQuestions) {
    SessionStats stats = this.shuffleCardsByDifficulty();
    List<Card> selectedCards = this.cards.stream().limit(numberOfQuestions).toList();
    // Updates session cards list to be only the selected cards
    this.sessionCards.addAll(selectedCards);
    // Creates the iterator using the finalized session cards
    this.cardIterator = this.sessionCards.listIterator();
    return stats;
  }

  /**
   * Overrides toString in class Object. Converts this set and all of its cards into a single string
   * and returns that string.
   *
   * @return the cards in this set as a single String
   */
  @Override
  public String toString() {
    return this.cards.stream().map(Card::toString)
        .collect(Collectors.joining("\n"));
  }

  /**
   * Gives the next card in the set using the iterator. Returns null if there is no next card.
   *
   * @return the card the is next in the set
   */
  public Card nextCard() {
    Card result = null;
    if (this.cardIterator != null && this.cardIterator.hasNext()) {
      result = this.cardIterator.next();
    }
    return result;
  }

  /**
   * Updates the list of cards in this set with the given list of cards. Used during the
   * construction of a set from a read path.
   *
   * @param cards the cards
   */
  public void updateCards(Collection<? extends Card> cards) {
    this.cards.addAll(new ArrayList<>(cards));
  }

  /**
   * Determines if a given obj and this study set are equal based on their cards.
   *
   * @param obj the object this study set is being compared to
   * @return whether the given object and this study set are equal
   */
  @Override
  public boolean equals(Object obj) {
    boolean result = false;
    if (obj != null) {
      if (this.getClass() == obj.getClass()) {
        StudySet other = (StudySet) obj;
        result = this.toString().equals(other.toString());
      }
    }
    return result;
  }

  /**
   * Returns the hashCode for this card that's used for bucketing in Hash implementations.
   *
   * @return hash generated by the hashing algorithm
   */
  @Override
  public int hashCode() {
    return Objects.hash(this.cards);
  }
}
